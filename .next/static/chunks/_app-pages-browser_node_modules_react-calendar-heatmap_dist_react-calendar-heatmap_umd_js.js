/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_react-calendar-heatmap_dist_react-calendar-heatmap_umd_js"],{

/***/ "(app-pages-browser)/./node_modules/react-calendar-heatmap/dist/react-calendar-heatmap.umd.js":
/*!********************************************************************************!*\
  !*** ./node_modules/react-calendar-heatmap/dist/react-calendar-heatmap.umd.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\")) :\n  0;\n}(this, (function (React) { 'use strict';\n\n  React = React && React.hasOwnProperty('default') ? React['default'] : React;\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n      return;\n    }\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\n  var ReactPropTypesSecret_1 = ReactPropTypesSecret;\n\n  function emptyFunction() {}\n  function emptyFunctionWithReset() {}\n  emptyFunctionWithReset.resetWarningCache = emptyFunction;\n\n  var factoryWithThrowingShims = function() {\n    function shim(props, propName, componentName, location, propFullName, secret) {\n      if (secret === ReactPropTypesSecret_1) {\n        // It is still safe when called from React.\n        return;\n      }\n      var err = new Error(\n        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n        'Use PropTypes.checkPropTypes() to call them. ' +\n        'Read more at http://fb.me/use-check-prop-types'\n      );\n      err.name = 'Invariant Violation';\n      throw err;\n    }  shim.isRequired = shim;\n    function getShim() {\n      return shim;\n    }  // Important!\n    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n    var ReactPropTypes = {\n      array: shim,\n      bool: shim,\n      func: shim,\n      number: shim,\n      object: shim,\n      string: shim,\n      symbol: shim,\n\n      any: shim,\n      arrayOf: getShim,\n      element: shim,\n      elementType: shim,\n      instanceOf: getShim,\n      node: shim,\n      objectOf: getShim,\n      oneOf: getShim,\n      oneOfType: getShim,\n      shape: getShim,\n      exact: getShim,\n\n      checkPropTypes: emptyFunctionWithReset,\n      resetWarningCache: emptyFunction\n    };\n\n    ReactPropTypes.PropTypes = ReactPropTypes;\n\n    return ReactPropTypes;\n  };\n\n  var propTypes = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  {\n    // By explicitly using `prop-types` you are opting into new production behavior.\n    // http://fb.me/prop-types-in-prod\n    module.exports = factoryWithThrowingShims();\n  }\n  });\n\n  function areInputsEqual(newInputs, lastInputs) {\n      if (newInputs.length !== lastInputs.length) {\n          return false;\n      }\n      for (var i = 0; i < newInputs.length; i++) {\n          if (newInputs[i] !== lastInputs[i]) {\n              return false;\n          }\n      }\n      return true;\n  }\n\n  function memoizeOne(resultFn, isEqual) {\n      if (isEqual === void 0) { isEqual = areInputsEqual; }\n      var lastThis;\n      var lastArgs = [];\n      var lastResult;\n      var calledOnce = false;\n      function memoized() {\n          var newArgs = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              newArgs[_i] = arguments[_i];\n          }\n          if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n              return lastResult;\n          }\n          lastResult = resultFn.apply(this, newArgs);\n          calledOnce = true;\n          lastThis = this;\n          lastArgs = newArgs;\n          return lastResult;\n      }\n      return memoized;\n  }\n\n  var MILLISECONDS_IN_ONE_DAY = 24 * 60 * 60 * 1000;\n  var DAYS_IN_WEEK = 7;\n  var MONTH_LABELS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  var DAY_LABELS = ['', 'Mon', '', 'Wed', '', 'Fri', ''];\n\n  // returns a new date shifted a certain number of days (can be negative)\n  function shiftDate(date, numDays) {\n    var newDate = new Date(date);\n    newDate.setDate(newDate.getDate() + numDays);\n    return newDate;\n  }\n  function getBeginningTimeForDate(date) {\n    return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n  } // obj can be a parseable string, a millisecond timestamp, or a Date object\n\n  function convertToDate(obj) {\n    return obj instanceof Date ? obj : new Date(obj);\n  }\n  function dateNDaysAgo(numDaysAgo) {\n    return shiftDate(new Date(), -numDaysAgo);\n  }\n  function getRange(count) {\n    var arr = [];\n\n    for (var idx = 0; idx < count; idx += 1) {\n      arr.push(idx);\n    }\n\n    return arr;\n  }\n\n  var SQUARE_SIZE = 10;\n  var MONTH_LABEL_GUTTER_SIZE = 4;\n  var CSS_PSEDUO_NAMESPACE = 'react-calendar-heatmap-';\n\n  var CalendarHeatmap =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(CalendarHeatmap, _React$Component);\n\n    function CalendarHeatmap() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, CalendarHeatmap);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CalendarHeatmap)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_this), \"getValueCache\", memoizeOne(function (props) {\n        return props.values.reduce(function (memo, value) {\n          var date = convertToDate(value.date);\n          var index = Math.floor((date - _this.getStartDateWithEmptyDays()) / MILLISECONDS_IN_ONE_DAY); // eslint-disable-next-line no-param-reassign\n\n          memo[index] = {\n            value: value,\n            className: _this.props.classForValue(value),\n            title: _this.props.titleForValue ? _this.props.titleForValue(value) : null,\n            tooltipDataAttrs: _this.getTooltipDataAttrsForValue(value)\n          };\n          return memo;\n        }, {});\n      }));\n\n      return _this;\n    }\n\n    _createClass(CalendarHeatmap, [{\n      key: \"getDateDifferenceInDays\",\n      value: function getDateDifferenceInDays() {\n        var _this$props = this.props,\n            startDate = _this$props.startDate,\n            numDays = _this$props.numDays;\n\n        if (numDays) {\n          // eslint-disable-next-line no-console\n          console.warn('numDays is a deprecated prop. It will be removed in the next release. Consider using the startDate prop instead.');\n          return numDays;\n        }\n\n        var timeDiff = this.getEndDate() - convertToDate(startDate);\n        return Math.ceil(timeDiff / MILLISECONDS_IN_ONE_DAY);\n      }\n    }, {\n      key: \"getSquareSizeWithGutter\",\n      value: function getSquareSizeWithGutter() {\n        return SQUARE_SIZE + this.props.gutterSize;\n      }\n    }, {\n      key: \"getMonthLabelSize\",\n      value: function getMonthLabelSize() {\n        if (!this.props.showMonthLabels) {\n          return 0;\n        }\n\n        if (this.props.horizontal) {\n          return SQUARE_SIZE + MONTH_LABEL_GUTTER_SIZE;\n        }\n\n        return 2 * (SQUARE_SIZE + MONTH_LABEL_GUTTER_SIZE);\n      }\n    }, {\n      key: \"getWeekdayLabelSize\",\n      value: function getWeekdayLabelSize() {\n        if (!this.props.showWeekdayLabels) {\n          return 0;\n        }\n\n        if (this.props.horizontal) {\n          return 30;\n        }\n\n        return SQUARE_SIZE * 1.5;\n      }\n    }, {\n      key: \"getStartDate\",\n      value: function getStartDate() {\n        return shiftDate(this.getEndDate(), -this.getDateDifferenceInDays() + 1); // +1 because endDate is inclusive\n      }\n    }, {\n      key: \"getEndDate\",\n      value: function getEndDate() {\n        return getBeginningTimeForDate(convertToDate(this.props.endDate));\n      }\n    }, {\n      key: \"getStartDateWithEmptyDays\",\n      value: function getStartDateWithEmptyDays() {\n        return shiftDate(this.getStartDate(), -this.getNumEmptyDaysAtStart());\n      }\n    }, {\n      key: \"getNumEmptyDaysAtStart\",\n      value: function getNumEmptyDaysAtStart() {\n        return this.getStartDate().getDay();\n      }\n    }, {\n      key: \"getNumEmptyDaysAtEnd\",\n      value: function getNumEmptyDaysAtEnd() {\n        return DAYS_IN_WEEK - 1 - this.getEndDate().getDay();\n      }\n    }, {\n      key: \"getWeekCount\",\n      value: function getWeekCount() {\n        var numDaysRoundedToWeek = this.getDateDifferenceInDays() + this.getNumEmptyDaysAtStart() + this.getNumEmptyDaysAtEnd();\n        return Math.ceil(numDaysRoundedToWeek / DAYS_IN_WEEK);\n      }\n    }, {\n      key: \"getWeekWidth\",\n      value: function getWeekWidth() {\n        return DAYS_IN_WEEK * this.getSquareSizeWithGutter();\n      }\n    }, {\n      key: \"getWidth\",\n      value: function getWidth() {\n        return this.getWeekCount() * this.getSquareSizeWithGutter() - (this.props.gutterSize - this.getWeekdayLabelSize());\n      }\n    }, {\n      key: \"getHeight\",\n      value: function getHeight() {\n        return this.getWeekWidth() + (this.getMonthLabelSize() - this.props.gutterSize) + this.getWeekdayLabelSize();\n      }\n    }, {\n      key: \"getValueForIndex\",\n      value: function getValueForIndex(index) {\n        if (this.valueCache[index]) {\n          return this.valueCache[index].value;\n        }\n\n        return null;\n      }\n    }, {\n      key: \"getClassNameForIndex\",\n      value: function getClassNameForIndex(index) {\n        if (this.valueCache[index]) {\n          return this.valueCache[index].className;\n        }\n\n        return this.props.classForValue(null);\n      }\n    }, {\n      key: \"getTitleForIndex\",\n      value: function getTitleForIndex(index) {\n        if (this.valueCache[index]) {\n          return this.valueCache[index].title;\n        }\n\n        return this.props.titleForValue ? this.props.titleForValue(null) : null;\n      }\n    }, {\n      key: \"getTooltipDataAttrsForIndex\",\n      value: function getTooltipDataAttrsForIndex(index) {\n        if (this.valueCache[index]) {\n          return this.valueCache[index].tooltipDataAttrs;\n        }\n\n        return this.getTooltipDataAttrsForValue({\n          date: null,\n          count: null\n        });\n      }\n    }, {\n      key: \"getTooltipDataAttrsForValue\",\n      value: function getTooltipDataAttrsForValue(value) {\n        var tooltipDataAttrs = this.props.tooltipDataAttrs;\n\n        if (typeof tooltipDataAttrs === 'function') {\n          return tooltipDataAttrs(value);\n        }\n\n        return tooltipDataAttrs;\n      }\n    }, {\n      key: \"getTransformForWeek\",\n      value: function getTransformForWeek(weekIndex) {\n        if (this.props.horizontal) {\n          return \"translate(\".concat(weekIndex * this.getSquareSizeWithGutter(), \", 0)\");\n        }\n\n        return \"translate(0, \".concat(weekIndex * this.getSquareSizeWithGutter(), \")\");\n      }\n    }, {\n      key: \"getTransformForWeekdayLabels\",\n      value: function getTransformForWeekdayLabels() {\n        if (this.props.horizontal) {\n          return \"translate(\".concat(SQUARE_SIZE, \", \").concat(this.getMonthLabelSize(), \")\");\n        }\n\n        return null;\n      }\n    }, {\n      key: \"getTransformForMonthLabels\",\n      value: function getTransformForMonthLabels() {\n        if (this.props.horizontal) {\n          return \"translate(\".concat(this.getWeekdayLabelSize(), \", 0)\");\n        }\n\n        return \"translate(\".concat(this.getWeekWidth() + MONTH_LABEL_GUTTER_SIZE, \", \").concat(this.getWeekdayLabelSize(), \")\");\n      }\n    }, {\n      key: \"getTransformForAllWeeks\",\n      value: function getTransformForAllWeeks() {\n        if (this.props.horizontal) {\n          return \"translate(\".concat(this.getWeekdayLabelSize(), \", \").concat(this.getMonthLabelSize(), \")\");\n        }\n\n        return \"translate(0, \".concat(this.getWeekdayLabelSize(), \")\");\n      }\n    }, {\n      key: \"getViewBox\",\n      value: function getViewBox() {\n        if (this.props.horizontal) {\n          return \"0 0 \".concat(this.getWidth(), \" \").concat(this.getHeight());\n        }\n\n        return \"0 0 \".concat(this.getHeight(), \" \").concat(this.getWidth());\n      }\n    }, {\n      key: \"getSquareCoordinates\",\n      value: function getSquareCoordinates(dayIndex) {\n        if (this.props.horizontal) {\n          return [0, dayIndex * this.getSquareSizeWithGutter()];\n        }\n\n        return [dayIndex * this.getSquareSizeWithGutter(), 0];\n      }\n    }, {\n      key: \"getWeekdayLabelCoordinates\",\n      value: function getWeekdayLabelCoordinates(dayIndex) {\n        if (this.props.horizontal) {\n          return [0, (dayIndex + 1) * SQUARE_SIZE + dayIndex * this.props.gutterSize];\n        }\n\n        return [dayIndex * SQUARE_SIZE + dayIndex * this.props.gutterSize, SQUARE_SIZE];\n      }\n    }, {\n      key: \"getMonthLabelCoordinates\",\n      value: function getMonthLabelCoordinates(weekIndex) {\n        if (this.props.horizontal) {\n          return [weekIndex * this.getSquareSizeWithGutter(), this.getMonthLabelSize() - MONTH_LABEL_GUTTER_SIZE];\n        }\n\n        var verticalOffset = -2;\n        return [0, (weekIndex + 1) * this.getSquareSizeWithGutter() + verticalOffset];\n      }\n    }, {\n      key: \"handleClick\",\n      value: function handleClick(value) {\n        if (this.props.onClick) {\n          this.props.onClick(value);\n        }\n      }\n    }, {\n      key: \"handleMouseOver\",\n      value: function handleMouseOver(e, value) {\n        if (this.props.onMouseOver) {\n          this.props.onMouseOver(e, value);\n        }\n      }\n    }, {\n      key: \"handleMouseLeave\",\n      value: function handleMouseLeave(e, value) {\n        if (this.props.onMouseLeave) {\n          this.props.onMouseLeave(e, value);\n        }\n      }\n    }, {\n      key: \"renderSquare\",\n      value: function renderSquare(dayIndex, index) {\n        var _this2 = this;\n\n        var indexOutOfRange = index < this.getNumEmptyDaysAtStart() || index >= this.getNumEmptyDaysAtStart() + this.getDateDifferenceInDays();\n\n        if (indexOutOfRange && !this.props.showOutOfRangeDays) {\n          return null;\n        }\n\n        var _this$getSquareCoordi = this.getSquareCoordinates(dayIndex),\n            _this$getSquareCoordi2 = _slicedToArray(_this$getSquareCoordi, 2),\n            x = _this$getSquareCoordi2[0],\n            y = _this$getSquareCoordi2[1];\n\n        var value = this.getValueForIndex(index);\n        var rect = // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events\n        React.createElement(\"rect\", _extends({\n          key: index,\n          width: SQUARE_SIZE,\n          height: SQUARE_SIZE,\n          x: x,\n          y: y,\n          className: this.getClassNameForIndex(index),\n          onClick: function onClick() {\n            return _this2.handleClick(value);\n          },\n          onMouseOver: function onMouseOver(e) {\n            return _this2.handleMouseOver(e, value);\n          },\n          onMouseLeave: function onMouseLeave(e) {\n            return _this2.handleMouseLeave(e, value);\n          }\n        }, this.getTooltipDataAttrsForIndex(index)), React.createElement(\"title\", null, this.getTitleForIndex(index)));\n        var transformDayElement = this.props.transformDayElement;\n        return transformDayElement ? transformDayElement(rect, value, index) : rect;\n      }\n    }, {\n      key: \"renderWeek\",\n      value: function renderWeek(weekIndex) {\n        var _this3 = this;\n\n        return React.createElement(\"g\", {\n          key: weekIndex,\n          transform: this.getTransformForWeek(weekIndex),\n          className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"week\")\n        }, getRange(DAYS_IN_WEEK).map(function (dayIndex) {\n          return _this3.renderSquare(dayIndex, weekIndex * DAYS_IN_WEEK + dayIndex);\n        }));\n      }\n    }, {\n      key: \"renderAllWeeks\",\n      value: function renderAllWeeks() {\n        var _this4 = this;\n\n        return getRange(this.getWeekCount()).map(function (weekIndex) {\n          return _this4.renderWeek(weekIndex);\n        });\n      }\n    }, {\n      key: \"renderMonthLabels\",\n      value: function renderMonthLabels() {\n        var _this5 = this;\n\n        if (!this.props.showMonthLabels) {\n          return null;\n        }\n\n        var weekRange = getRange(this.getWeekCount() - 1); // don't render for last week, because label will be cut off\n\n        return weekRange.map(function (weekIndex) {\n          var endOfWeek = shiftDate(_this5.getStartDateWithEmptyDays(), (weekIndex + 1) * DAYS_IN_WEEK);\n\n          var _this5$getMonthLabelC = _this5.getMonthLabelCoordinates(weekIndex),\n              _this5$getMonthLabelC2 = _slicedToArray(_this5$getMonthLabelC, 2),\n              x = _this5$getMonthLabelC2[0],\n              y = _this5$getMonthLabelC2[1];\n\n          return endOfWeek.getDate() >= 1 && endOfWeek.getDate() <= DAYS_IN_WEEK ? React.createElement(\"text\", {\n            key: weekIndex,\n            x: x,\n            y: y,\n            className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"month-label\")\n          }, _this5.props.monthLabels[endOfWeek.getMonth()]) : null;\n        });\n      }\n    }, {\n      key: \"renderWeekdayLabels\",\n      value: function renderWeekdayLabels() {\n        var _this6 = this;\n\n        if (!this.props.showWeekdayLabels) {\n          return null;\n        }\n\n        return this.props.weekdayLabels.map(function (weekdayLabel, dayIndex) {\n          var _this6$getWeekdayLabe = _this6.getWeekdayLabelCoordinates(dayIndex),\n              _this6$getWeekdayLabe2 = _slicedToArray(_this6$getWeekdayLabe, 2),\n              x = _this6$getWeekdayLabe2[0],\n              y = _this6$getWeekdayLabe2[1];\n\n          var cssClasses = \"\".concat(_this6.props.horizontal ? '' : \"\".concat(CSS_PSEDUO_NAMESPACE, \"small-text\"), \" \").concat(CSS_PSEDUO_NAMESPACE, \"weekday-label\"); // eslint-disable-next-line no-bitwise\n\n          return dayIndex & 1 ? React.createElement(\"text\", {\n            key: \"\".concat(x).concat(y),\n            x: x,\n            y: y,\n            className: cssClasses\n          }, weekdayLabel) : null;\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        this.valueCache = this.getValueCache(this.props);\n        return React.createElement(\"svg\", {\n          className: \"react-calendar-heatmap\",\n          viewBox: this.getViewBox()\n        }, React.createElement(\"g\", {\n          transform: this.getTransformForMonthLabels(),\n          className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"month-labels\")\n        }, this.renderMonthLabels()), React.createElement(\"g\", {\n          transform: this.getTransformForAllWeeks(),\n          className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"all-weeks\")\n        }, this.renderAllWeeks()), React.createElement(\"g\", {\n          transform: this.getTransformForWeekdayLabels(),\n          className: \"\".concat(CSS_PSEDUO_NAMESPACE, \"weekday-labels\")\n        }, this.renderWeekdayLabels()));\n      }\n    }]);\n\n    return CalendarHeatmap;\n  }(React.Component);\n\n  CalendarHeatmap.propTypes = {\n    values: propTypes.arrayOf(propTypes.shape({\n      date: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.instanceOf(Date)]).isRequired\n    }).isRequired).isRequired,\n    // array of objects with date and arbitrary metadata\n    numDays: propTypes.number,\n    // number of days back from endDate to show\n    startDate: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.instanceOf(Date)]),\n    // start of date range\n    endDate: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.instanceOf(Date)]),\n    // end of date range\n    gutterSize: propTypes.number,\n    // size of space between squares\n    horizontal: propTypes.bool,\n    // whether to orient horizontally or vertically\n    showMonthLabels: propTypes.bool,\n    // whether to show month labels\n    showWeekdayLabels: propTypes.bool,\n    // whether to show weekday labels\n    showOutOfRangeDays: propTypes.bool,\n    // whether to render squares for extra days in week after endDate, and before start date\n    tooltipDataAttrs: propTypes.oneOfType([propTypes.object, propTypes.func]),\n    // data attributes to add to square for setting 3rd party tooltips, e.g. { 'data-toggle': 'tooltip' } for bootstrap tooltips\n    titleForValue: propTypes.func,\n    // function which returns title text for value\n    classForValue: propTypes.func,\n    // function which returns html class for value\n    monthLabels: propTypes.arrayOf(propTypes.string),\n    // An array with 12 strings representing the text from janurary to december\n    weekdayLabels: propTypes.arrayOf(propTypes.string),\n    // An array with 7 strings representing the text from Sun to Sat\n    onClick: propTypes.func,\n    // callback function when a square is clicked\n    onMouseOver: propTypes.func,\n    // callback function when mouse pointer is over a square\n    onMouseLeave: propTypes.func,\n    // callback function when mouse pointer is left a square\n    transformDayElement: propTypes.func // function to further transform the svg element for a single day\n\n  };\n  CalendarHeatmap.defaultProps = {\n    numDays: null,\n    startDate: dateNDaysAgo(200),\n    endDate: new Date(),\n    gutterSize: 1,\n    horizontal: true,\n    showMonthLabels: true,\n    showWeekdayLabels: false,\n    showOutOfRangeDays: false,\n    tooltipDataAttrs: null,\n    titleForValue: null,\n    classForValue: function classForValue(value) {\n      return value ? 'color-filled' : 'color-empty';\n    },\n    monthLabels: MONTH_LABELS,\n    weekdayLabels: DAY_LABELS,\n    onClick: null,\n    onMouseOver: null,\n    onMouseLeave: null,\n    transformDayElement: null\n  };\n\n  return CalendarHeatmap;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1jYWxlbmRhci1oZWF0bWFwL2Rpc3QvcmVhY3QtY2FsZW5kYXItaGVhdG1hcC51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELDRCQUE0QixtQkFBTyxDQUFDLG1GQUFPO0FBQ3pHLEVBQUUsQ0FDeUU7QUFDM0UsQ0FBQywyQkFBMkI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsK0JBQStCO0FBQy9FOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVLQUF1Szs7QUFFdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSwyQkFBMkI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FsZW5kYXItaGVhdG1hcC9kaXN0L3JlYWN0LWNhbGVuZGFyLWhlYXRtYXAudW1kLmpzPzE4MzAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3JlYWN0JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5DYWxlbmRhckhlYXRtYXAgPSBmYWN0b3J5KGdsb2JhbC5SZWFjdCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBSZWFjdCA9IFJlYWN0ICYmIFJlYWN0Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBSZWFjdFsnZGVmYXVsdCddIDogUmVhY3Q7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICAvKipcbiAgICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqL1xuXG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuICBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG4gIGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG4gIHZhciBmYWN0b3J5V2l0aFRocm93aW5nU2hpbXMgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSB7XG4gICAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgKTtcbiAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gICAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICAgIHJldHVybiBzaGltO1xuICAgIH0gIC8vIEltcG9ydGFudCFcbiAgICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgICBhcnJheTogc2hpbSxcbiAgICAgIGJvb2w6IHNoaW0sXG4gICAgICBmdW5jOiBzaGltLFxuICAgICAgbnVtYmVyOiBzaGltLFxuICAgICAgb2JqZWN0OiBzaGltLFxuICAgICAgc3RyaW5nOiBzaGltLFxuICAgICAgc3ltYm9sOiBzaGltLFxuXG4gICAgICBhbnk6IHNoaW0sXG4gICAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgICAgZWxlbWVudDogc2hpbSxcbiAgICAgIGVsZW1lbnRUeXBlOiBzaGltLFxuICAgICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICAgIG5vZGU6IHNoaW0sXG4gICAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICAgIG9uZU9mOiBnZXRTaGltLFxuICAgICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgICAgc2hhcGU6IGdldFNoaW0sXG4gICAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgICAgY2hlY2tQcm9wVHlwZXM6IGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQsXG4gICAgICByZXNldFdhcm5pbmdDYWNoZTogZW1wdHlGdW5jdGlvblxuICAgIH07XG5cbiAgICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICAgIHJldHVybiBSZWFjdFByb3BUeXBlcztcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvKipcbiAgICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqL1xuXG4gIHtcbiAgICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAgIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcygpO1xuICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFyZUlucHV0c0VxdWFsKG5ld0lucHV0cywgbGFzdElucHV0cykge1xuICAgICAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobmV3SW5wdXRzW2ldICE9PSBsYXN0SW5wdXRzW2ldKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwpIHtcbiAgICAgIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHsgaXNFcXVhbCA9IGFyZUlucHV0c0VxdWFsOyB9XG4gICAgICB2YXIgbGFzdFRoaXM7XG4gICAgICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgICAgIHZhciBsYXN0UmVzdWx0O1xuICAgICAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcbiAgICAgIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgICAgICAgIHZhciBuZXdBcmdzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgbmV3QXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGxhc3RBcmdzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gIH1cblxuICB2YXIgTUlMTElTRUNPTkRTX0lOX09ORV9EQVkgPSAyNCAqIDYwICogNjAgKiAxMDAwO1xuICB2YXIgREFZU19JTl9XRUVLID0gNztcbiAgdmFyIE1PTlRIX0xBQkVMUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbiAgdmFyIERBWV9MQUJFTFMgPSBbJycsICdNb24nLCAnJywgJ1dlZCcsICcnLCAnRnJpJywgJyddO1xuXG4gIC8vIHJldHVybnMgYSBuZXcgZGF0ZSBzaGlmdGVkIGEgY2VydGFpbiBudW1iZXIgb2YgZGF5cyAoY2FuIGJlIG5lZ2F0aXZlKVxuICBmdW5jdGlvbiBzaGlmdERhdGUoZGF0ZSwgbnVtRGF5cykge1xuICAgIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgbmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpICsgbnVtRGF5cyk7XG4gICAgcmV0dXJuIG5ld0RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QmVnaW5uaW5nVGltZUZvckRhdGUoZGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICB9IC8vIG9iaiBjYW4gYmUgYSBwYXJzZWFibGUgc3RyaW5nLCBhIG1pbGxpc2Vjb25kIHRpbWVzdGFtcCwgb3IgYSBEYXRlIG9iamVjdFxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUb0RhdGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGUgPyBvYmogOiBuZXcgRGF0ZShvYmopO1xuICB9XG4gIGZ1bmN0aW9uIGRhdGVORGF5c0FnbyhudW1EYXlzQWdvKSB7XG4gICAgcmV0dXJuIHNoaWZ0RGF0ZShuZXcgRGF0ZSgpLCAtbnVtRGF5c0Fnbyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmFuZ2UoY291bnQpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBjb3VudDsgaWR4ICs9IDEpIHtcbiAgICAgIGFyci5wdXNoKGlkeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHZhciBTUVVBUkVfU0laRSA9IDEwO1xuICB2YXIgTU9OVEhfTEFCRUxfR1VUVEVSX1NJWkUgPSA0O1xuICB2YXIgQ1NTX1BTRURVT19OQU1FU1BBQ0UgPSAncmVhY3QtY2FsZW5kYXItaGVhdG1hcC0nO1xuXG4gIHZhciBDYWxlbmRhckhlYXRtYXAgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENhbGVuZGFySGVhdG1hcCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBDYWxlbmRhckhlYXRtYXAoKSB7XG4gICAgICB2YXIgX2dldFByb3RvdHlwZU9mMjtcblxuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsZW5kYXJIZWF0bWFwKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9nZXRQcm90b3R5cGVPZjIgPSBfZ2V0UHJvdG90eXBlT2YoQ2FsZW5kYXJIZWF0bWFwKSkuY2FsbC5hcHBseShfZ2V0UHJvdG90eXBlT2YyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRWYWx1ZUNhY2hlXCIsIG1lbW9pemVPbmUoZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy52YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBkYXRlID0gY29udmVydFRvRGF0ZSh2YWx1ZS5kYXRlKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKChkYXRlIC0gX3RoaXMuZ2V0U3RhcnREYXRlV2l0aEVtcHR5RGF5cygpKSAvIE1JTExJU0VDT05EU19JTl9PTkVfREFZKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cbiAgICAgICAgICBtZW1vW2luZGV4XSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogX3RoaXMucHJvcHMuY2xhc3NGb3JWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICB0aXRsZTogX3RoaXMucHJvcHMudGl0bGVGb3JWYWx1ZSA/IF90aGlzLnByb3BzLnRpdGxlRm9yVmFsdWUodmFsdWUpIDogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBEYXRhQXR0cnM6IF90aGlzLmdldFRvb2x0aXBEYXRhQXR0cnNGb3JWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2FsZW5kYXJIZWF0bWFwLCBbe1xuICAgICAga2V5OiBcImdldERhdGVEaWZmZXJlbmNlSW5EYXlzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0ZURpZmZlcmVuY2VJbkRheXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBzdGFydERhdGUgPSBfdGhpcyRwcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgICBudW1EYXlzID0gX3RoaXMkcHJvcHMubnVtRGF5cztcblxuICAgICAgICBpZiAobnVtRGF5cykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdudW1EYXlzIGlzIGEgZGVwcmVjYXRlZCBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgdGhlIHN0YXJ0RGF0ZSBwcm9wIGluc3RlYWQuJyk7XG4gICAgICAgICAgcmV0dXJuIG51bURheXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGltZURpZmYgPSB0aGlzLmdldEVuZERhdGUoKSAtIGNvbnZlcnRUb0RhdGUoc3RhcnREYXRlKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aW1lRGlmZiAvIE1JTExJU0VDT05EU19JTl9PTkVfREFZKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U3F1YXJlU2l6ZVdpdGhHdXR0ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpIHtcbiAgICAgICAgcmV0dXJuIFNRVUFSRV9TSVpFICsgdGhpcy5wcm9wcy5ndXR0ZXJTaXplO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRNb250aExhYmVsU2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vbnRoTGFiZWxTaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuc2hvd01vbnRoTGFiZWxzKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgcmV0dXJuIFNRVUFSRV9TSVpFICsgTU9OVEhfTEFCRUxfR1VUVEVSX1NJWkU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMiAqIChTUVVBUkVfU0laRSArIE1PTlRIX0xBQkVMX0dVVFRFUl9TSVpFKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0V2Vla2RheUxhYmVsU2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdlZWtkYXlMYWJlbFNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93V2Vla2RheUxhYmVscykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTUVVBUkVfU0laRSAqIDEuNTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U3RhcnREYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnREYXRlKCkge1xuICAgICAgICByZXR1cm4gc2hpZnREYXRlKHRoaXMuZ2V0RW5kRGF0ZSgpLCAtdGhpcy5nZXREYXRlRGlmZmVyZW5jZUluRGF5cygpICsgMSk7IC8vICsxIGJlY2F1c2UgZW5kRGF0ZSBpcyBpbmNsdXNpdmVcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RW5kRGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVuZERhdGUoKSB7XG4gICAgICAgIHJldHVybiBnZXRCZWdpbm5pbmdUaW1lRm9yRGF0ZShjb252ZXJ0VG9EYXRlKHRoaXMucHJvcHMuZW5kRGF0ZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTdGFydERhdGVXaXRoRW1wdHlEYXlzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhcnREYXRlV2l0aEVtcHR5RGF5cygpIHtcbiAgICAgICAgcmV0dXJuIHNoaWZ0RGF0ZSh0aGlzLmdldFN0YXJ0RGF0ZSgpLCAtdGhpcy5nZXROdW1FbXB0eURheXNBdFN0YXJ0KCkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXROdW1FbXB0eURheXNBdFN0YXJ0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtRW1wdHlEYXlzQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnREYXRlKCkuZ2V0RGF5KCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE51bUVtcHR5RGF5c0F0RW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtRW1wdHlEYXlzQXRFbmQoKSB7XG4gICAgICAgIHJldHVybiBEQVlTX0lOX1dFRUsgLSAxIC0gdGhpcy5nZXRFbmREYXRlKCkuZ2V0RGF5KCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFdlZWtDb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdlZWtDb3VudCgpIHtcbiAgICAgICAgdmFyIG51bURheXNSb3VuZGVkVG9XZWVrID0gdGhpcy5nZXREYXRlRGlmZmVyZW5jZUluRGF5cygpICsgdGhpcy5nZXROdW1FbXB0eURheXNBdFN0YXJ0KCkgKyB0aGlzLmdldE51bUVtcHR5RGF5c0F0RW5kKCk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtRGF5c1JvdW5kZWRUb1dlZWsgLyBEQVlTX0lOX1dFRUspO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRXZWVrV2lkdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXZWVrV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBEQVlTX0lOX1dFRUsgKiB0aGlzLmdldFNxdWFyZVNpemVXaXRoR3V0dGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFdpZHRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdlZWtDb3VudCgpICogdGhpcy5nZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpIC0gKHRoaXMucHJvcHMuZ3V0dGVyU2l6ZSAtIHRoaXMuZ2V0V2Vla2RheUxhYmVsU2l6ZSgpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SGVpZ2h0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXZWVrV2lkdGgoKSArICh0aGlzLmdldE1vbnRoTGFiZWxTaXplKCkgLSB0aGlzLnByb3BzLmd1dHRlclNpemUpICsgdGhpcy5nZXRXZWVrZGF5TGFiZWxTaXplKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFZhbHVlRm9ySW5kZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUZvckluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlQ2FjaGVbaW5kZXhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDYWNoZVtpbmRleF0udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Q2xhc3NOYW1lRm9ySW5kZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGFzc05hbWVGb3JJbmRleChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUNhY2hlW2luZGV4XSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ2FjaGVbaW5kZXhdLmNsYXNzTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNsYXNzRm9yVmFsdWUobnVsbCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRpdGxlRm9ySW5kZXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZUZvckluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlQ2FjaGVbaW5kZXhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDYWNoZVtpbmRleF0udGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50aXRsZUZvclZhbHVlID8gdGhpcy5wcm9wcy50aXRsZUZvclZhbHVlKG51bGwpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0VG9vbHRpcERhdGFBdHRyc0ZvckluZGV4XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbHRpcERhdGFBdHRyc0ZvckluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlQ2FjaGVbaW5kZXhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDYWNoZVtpbmRleF0udG9vbHRpcERhdGFBdHRycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRvb2x0aXBEYXRhQXR0cnNGb3JWYWx1ZSh7XG4gICAgICAgICAgZGF0ZTogbnVsbCxcbiAgICAgICAgICBjb3VudDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0VG9vbHRpcERhdGFBdHRyc0ZvclZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbHRpcERhdGFBdHRyc0ZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b29sdGlwRGF0YUF0dHJzID0gdGhpcy5wcm9wcy50b29sdGlwRGF0YUF0dHJzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdG9vbHRpcERhdGFBdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0b29sdGlwRGF0YUF0dHJzKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b29sdGlwRGF0YUF0dHJzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRUcmFuc2Zvcm1Gb3JXZWVrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRm9yV2Vlayh3ZWVrSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQod2Vla0luZGV4ICogdGhpcy5nZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpLCBcIiwgMClcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIuY29uY2F0KHdlZWtJbmRleCAqIHRoaXMuZ2V0U3F1YXJlU2l6ZVdpdGhHdXR0ZXIoKSwgXCIpXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRUcmFuc2Zvcm1Gb3JXZWVrZGF5TGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRm9yV2Vla2RheUxhYmVscygpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQoU1FVQVJFX1NJWkUsIFwiLCBcIikuY29uY2F0KHRoaXMuZ2V0TW9udGhMYWJlbFNpemUoKSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFRyYW5zZm9ybUZvck1vbnRoTGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRm9yTW9udGhMYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmhvcml6b250YWwpIHtcbiAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRoaXMuZ2V0V2Vla2RheUxhYmVsU2l6ZSgpLCBcIiwgMClcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRoaXMuZ2V0V2Vla1dpZHRoKCkgKyBNT05USF9MQUJFTF9HVVRURVJfU0laRSwgXCIsIFwiKS5jb25jYXQodGhpcy5nZXRXZWVrZGF5TGFiZWxTaXplKCksIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0VHJhbnNmb3JtRm9yQWxsV2Vla3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Gb3JBbGxXZWVrcygpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQodGhpcy5nZXRXZWVrZGF5TGFiZWxTaXplKCksIFwiLCBcIikuY29uY2F0KHRoaXMuZ2V0TW9udGhMYWJlbFNpemUoKSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiLmNvbmNhdCh0aGlzLmdldFdlZWtkYXlMYWJlbFNpemUoKSwgXCIpXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRWaWV3Qm94XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld0JveCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBcIjAgMCBcIi5jb25jYXQodGhpcy5nZXRXaWR0aCgpLCBcIiBcIikuY29uY2F0KHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiMCAwIFwiLmNvbmNhdCh0aGlzLmdldEhlaWdodCgpLCBcIiBcIikuY29uY2F0KHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFNxdWFyZUNvb3JkaW5hdGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3F1YXJlQ29vcmRpbmF0ZXMoZGF5SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBbMCwgZGF5SW5kZXggKiB0aGlzLmdldFNxdWFyZVNpemVXaXRoR3V0dGVyKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtkYXlJbmRleCAqIHRoaXMuZ2V0U3F1YXJlU2l6ZVdpdGhHdXR0ZXIoKSwgMF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFdlZWtkYXlMYWJlbENvb3JkaW5hdGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2Vla2RheUxhYmVsQ29vcmRpbmF0ZXMoZGF5SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBbMCwgKGRheUluZGV4ICsgMSkgKiBTUVVBUkVfU0laRSArIGRheUluZGV4ICogdGhpcy5wcm9wcy5ndXR0ZXJTaXplXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZGF5SW5kZXggKiBTUVVBUkVfU0laRSArIGRheUluZGV4ICogdGhpcy5wcm9wcy5ndXR0ZXJTaXplLCBTUVVBUkVfU0laRV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE1vbnRoTGFiZWxDb29yZGluYXRlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vbnRoTGFiZWxDb29yZGluYXRlcyh3ZWVrSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBbd2Vla0luZGV4ICogdGhpcy5nZXRTcXVhcmVTaXplV2l0aEd1dHRlcigpLCB0aGlzLmdldE1vbnRoTGFiZWxTaXplKCkgLSBNT05USF9MQUJFTF9HVVRURVJfU0laRV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGljYWxPZmZzZXQgPSAtMjtcbiAgICAgICAgcmV0dXJuIFswLCAod2Vla0luZGV4ICsgMSkgKiB0aGlzLmdldFNxdWFyZVNpemVXaXRoR3V0dGVyKCkgKyB2ZXJ0aWNhbE9mZnNldF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25DbGljaykge1xuICAgICAgICAgIHRoaXMucHJvcHMub25DbGljayh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlTW91c2VPdmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VPdmVyKGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlT3ZlcihlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlTW91c2VMZWF2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Nb3VzZUxlYXZlKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlTGVhdmUoZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclNxdWFyZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNxdWFyZShkYXlJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGluZGV4T3V0T2ZSYW5nZSA9IGluZGV4IDwgdGhpcy5nZXROdW1FbXB0eURheXNBdFN0YXJ0KCkgfHwgaW5kZXggPj0gdGhpcy5nZXROdW1FbXB0eURheXNBdFN0YXJ0KCkgKyB0aGlzLmdldERhdGVEaWZmZXJlbmNlSW5EYXlzKCk7XG5cbiAgICAgICAgaWYgKGluZGV4T3V0T2ZSYW5nZSAmJiAhdGhpcy5wcm9wcy5zaG93T3V0T2ZSYW5nZURheXMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyRnZXRTcXVhcmVDb29yZGkgPSB0aGlzLmdldFNxdWFyZUNvb3JkaW5hdGVzKGRheUluZGV4KSxcbiAgICAgICAgICAgIF90aGlzJGdldFNxdWFyZUNvb3JkaTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRTcXVhcmVDb29yZGksIDIpLFxuICAgICAgICAgICAgeCA9IF90aGlzJGdldFNxdWFyZUNvb3JkaTJbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkZ2V0U3F1YXJlQ29vcmRpMlsxXTtcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlRm9ySW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgcmVjdCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9tb3VzZS1ldmVudHMtaGF2ZS1rZXktZXZlbnRzXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgIHdpZHRoOiBTUVVBUkVfU0laRSxcbiAgICAgICAgICBoZWlnaHQ6IFNRVUFSRV9TSVpFLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lRm9ySW5kZXgoaW5kZXgpLFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZUNsaWNrKHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbiBvbk1vdXNlT3ZlcihlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZU1vdXNlT3ZlcihlLCB2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmhhbmRsZU1vdXNlTGVhdmUoZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5nZXRUb29sdGlwRGF0YUF0dHJzRm9ySW5kZXgoaW5kZXgpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRoaXMuZ2V0VGl0bGVGb3JJbmRleChpbmRleCkpKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybURheUVsZW1lbnQgPSB0aGlzLnByb3BzLnRyYW5zZm9ybURheUVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1EYXlFbGVtZW50ID8gdHJhbnNmb3JtRGF5RWxlbWVudChyZWN0LCB2YWx1ZSwgaW5kZXgpIDogcmVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyV2Vla1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcldlZWsod2Vla0luZGV4KSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICAgICAga2V5OiB3ZWVrSW5kZXgsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldFRyYW5zZm9ybUZvcldlZWsod2Vla0luZGV4KSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcIndlZWtcIilcbiAgICAgICAgfSwgZ2V0UmFuZ2UoREFZU19JTl9XRUVLKS5tYXAoZnVuY3Rpb24gKGRheUluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5yZW5kZXJTcXVhcmUoZGF5SW5kZXgsIHdlZWtJbmRleCAqIERBWVNfSU5fV0VFSyArIGRheUluZGV4KTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJBbGxXZWVrc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckFsbFdlZWtzKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZ2V0UmFuZ2UodGhpcy5nZXRXZWVrQ291bnQoKSkubWFwKGZ1bmN0aW9uICh3ZWVrSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnJlbmRlcldlZWsod2Vla0luZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlck1vbnRoTGFiZWxzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTW9udGhMYWJlbHMoKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93TW9udGhMYWJlbHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ZWVrUmFuZ2UgPSBnZXRSYW5nZSh0aGlzLmdldFdlZWtDb3VudCgpIC0gMSk7IC8vIGRvbid0IHJlbmRlciBmb3IgbGFzdCB3ZWVrLCBiZWNhdXNlIGxhYmVsIHdpbGwgYmUgY3V0IG9mZlxuXG4gICAgICAgIHJldHVybiB3ZWVrUmFuZ2UubWFwKGZ1bmN0aW9uICh3ZWVrSW5kZXgpIHtcbiAgICAgICAgICB2YXIgZW5kT2ZXZWVrID0gc2hpZnREYXRlKF90aGlzNS5nZXRTdGFydERhdGVXaXRoRW1wdHlEYXlzKCksICh3ZWVrSW5kZXggKyAxKSAqIERBWVNfSU5fV0VFSyk7XG5cbiAgICAgICAgICB2YXIgX3RoaXM1JGdldE1vbnRoTGFiZWxDID0gX3RoaXM1LmdldE1vbnRoTGFiZWxDb29yZGluYXRlcyh3ZWVrSW5kZXgpLFxuICAgICAgICAgICAgICBfdGhpczUkZ2V0TW9udGhMYWJlbEMyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXM1JGdldE1vbnRoTGFiZWxDLCAyKSxcbiAgICAgICAgICAgICAgeCA9IF90aGlzNSRnZXRNb250aExhYmVsQzJbMF0sXG4gICAgICAgICAgICAgIHkgPSBfdGhpczUkZ2V0TW9udGhMYWJlbEMyWzFdO1xuXG4gICAgICAgICAgcmV0dXJuIGVuZE9mV2Vlay5nZXREYXRlKCkgPj0gMSAmJiBlbmRPZldlZWsuZ2V0RGF0ZSgpIDw9IERBWVNfSU5fV0VFSyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICAgICAgICAgIGtleTogd2Vla0luZGV4LFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcIm1vbnRoLWxhYmVsXCIpXG4gICAgICAgICAgfSwgX3RoaXM1LnByb3BzLm1vbnRoTGFiZWxzW2VuZE9mV2Vlay5nZXRNb250aCgpXSkgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyV2Vla2RheUxhYmVsc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcldlZWtkYXlMYWJlbHMoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93V2Vla2RheUxhYmVscykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMud2Vla2RheUxhYmVscy5tYXAoZnVuY3Rpb24gKHdlZWtkYXlMYWJlbCwgZGF5SW5kZXgpIHtcbiAgICAgICAgICB2YXIgX3RoaXM2JGdldFdlZWtkYXlMYWJlID0gX3RoaXM2LmdldFdlZWtkYXlMYWJlbENvb3JkaW5hdGVzKGRheUluZGV4KSxcbiAgICAgICAgICAgICAgX3RoaXM2JGdldFdlZWtkYXlMYWJlMiA9IF9zbGljZWRUb0FycmF5KF90aGlzNiRnZXRXZWVrZGF5TGFiZSwgMiksXG4gICAgICAgICAgICAgIHggPSBfdGhpczYkZ2V0V2Vla2RheUxhYmUyWzBdLFxuICAgICAgICAgICAgICB5ID0gX3RoaXM2JGdldFdlZWtkYXlMYWJlMlsxXTtcblxuICAgICAgICAgIHZhciBjc3NDbGFzc2VzID0gXCJcIi5jb25jYXQoX3RoaXM2LnByb3BzLmhvcml6b250YWwgPyAnJyA6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcInNtYWxsLXRleHRcIiksIFwiIFwiKS5jb25jYXQoQ1NTX1BTRURVT19OQU1FU1BBQ0UsIFwid2Vla2RheS1sYWJlbFwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgICAgIHJldHVybiBkYXlJbmRleCAmIDEgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCB7XG4gICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KHgpLmNvbmNhdCh5KSxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzXG4gICAgICAgICAgfSwgd2Vla2RheUxhYmVsKSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMudmFsdWVDYWNoZSA9IHRoaXMuZ2V0VmFsdWVDYWNoZSh0aGlzLnByb3BzKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1jYWxlbmRhci1oZWF0bWFwXCIsXG4gICAgICAgICAgdmlld0JveDogdGhpcy5nZXRWaWV3Qm94KClcbiAgICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5nZXRUcmFuc2Zvcm1Gb3JNb250aExhYmVscygpLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoQ1NTX1BTRURVT19OQU1FU1BBQ0UsIFwibW9udGgtbGFiZWxzXCIpXG4gICAgICAgIH0sIHRoaXMucmVuZGVyTW9udGhMYWJlbHMoKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuZ2V0VHJhbnNmb3JtRm9yQWxsV2Vla3MoKSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcImFsbC13ZWVrc1wiKVxuICAgICAgICB9LCB0aGlzLnJlbmRlckFsbFdlZWtzKCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldFRyYW5zZm9ybUZvcldlZWtkYXlMYWJlbHMoKSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KENTU19QU0VEVU9fTkFNRVNQQUNFLCBcIndlZWtkYXktbGFiZWxzXCIpXG4gICAgICAgIH0sIHRoaXMucmVuZGVyV2Vla2RheUxhYmVscygpKSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENhbGVuZGFySGVhdG1hcDtcbiAgfShSZWFjdC5Db21wb25lbnQpO1xuXG4gIENhbGVuZGFySGVhdG1hcC5wcm9wVHlwZXMgPSB7XG4gICAgdmFsdWVzOiBwcm9wVHlwZXMuYXJyYXlPZihwcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgZGF0ZTogcHJvcFR5cGVzLm9uZU9mVHlwZShbcHJvcFR5cGVzLnN0cmluZywgcHJvcFR5cGVzLm51bWJlciwgcHJvcFR5cGVzLmluc3RhbmNlT2YoRGF0ZSldKS5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZCkuaXNSZXF1aXJlZCxcbiAgICAvLyBhcnJheSBvZiBvYmplY3RzIHdpdGggZGF0ZSBhbmQgYXJiaXRyYXJ5IG1ldGFkYXRhXG4gICAgbnVtRGF5czogcHJvcFR5cGVzLm51bWJlcixcbiAgICAvLyBudW1iZXIgb2YgZGF5cyBiYWNrIGZyb20gZW5kRGF0ZSB0byBzaG93XG4gICAgc3RhcnREYXRlOiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMuc3RyaW5nLCBwcm9wVHlwZXMubnVtYmVyLCBwcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKV0pLFxuICAgIC8vIHN0YXJ0IG9mIGRhdGUgcmFuZ2VcbiAgICBlbmREYXRlOiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMuc3RyaW5nLCBwcm9wVHlwZXMubnVtYmVyLCBwcm9wVHlwZXMuaW5zdGFuY2VPZihEYXRlKV0pLFxuICAgIC8vIGVuZCBvZiBkYXRlIHJhbmdlXG4gICAgZ3V0dGVyU2l6ZTogcHJvcFR5cGVzLm51bWJlcixcbiAgICAvLyBzaXplIG9mIHNwYWNlIGJldHdlZW4gc3F1YXJlc1xuICAgIGhvcml6b250YWw6IHByb3BUeXBlcy5ib29sLFxuICAgIC8vIHdoZXRoZXIgdG8gb3JpZW50IGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gICAgc2hvd01vbnRoTGFiZWxzOiBwcm9wVHlwZXMuYm9vbCxcbiAgICAvLyB3aGV0aGVyIHRvIHNob3cgbW9udGggbGFiZWxzXG4gICAgc2hvd1dlZWtkYXlMYWJlbHM6IHByb3BUeXBlcy5ib29sLFxuICAgIC8vIHdoZXRoZXIgdG8gc2hvdyB3ZWVrZGF5IGxhYmVsc1xuICAgIHNob3dPdXRPZlJhbmdlRGF5czogcHJvcFR5cGVzLmJvb2wsXG4gICAgLy8gd2hldGhlciB0byByZW5kZXIgc3F1YXJlcyBmb3IgZXh0cmEgZGF5cyBpbiB3ZWVrIGFmdGVyIGVuZERhdGUsIGFuZCBiZWZvcmUgc3RhcnQgZGF0ZVxuICAgIHRvb2x0aXBEYXRhQXR0cnM6IHByb3BUeXBlcy5vbmVPZlR5cGUoW3Byb3BUeXBlcy5vYmplY3QsIHByb3BUeXBlcy5mdW5jXSksXG4gICAgLy8gZGF0YSBhdHRyaWJ1dGVzIHRvIGFkZCB0byBzcXVhcmUgZm9yIHNldHRpbmcgM3JkIHBhcnR5IHRvb2x0aXBzLCBlLmcuIHsgJ2RhdGEtdG9nZ2xlJzogJ3Rvb2x0aXAnIH0gZm9yIGJvb3RzdHJhcCB0b29sdGlwc1xuICAgIHRpdGxlRm9yVmFsdWU6IHByb3BUeXBlcy5mdW5jLFxuICAgIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGl0bGUgdGV4dCBmb3IgdmFsdWVcbiAgICBjbGFzc0ZvclZhbHVlOiBwcm9wVHlwZXMuZnVuYyxcbiAgICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGh0bWwgY2xhc3MgZm9yIHZhbHVlXG4gICAgbW9udGhMYWJlbHM6IHByb3BUeXBlcy5hcnJheU9mKHByb3BUeXBlcy5zdHJpbmcpLFxuICAgIC8vIEFuIGFycmF5IHdpdGggMTIgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIHRleHQgZnJvbSBqYW51cmFyeSB0byBkZWNlbWJlclxuICAgIHdlZWtkYXlMYWJlbHM6IHByb3BUeXBlcy5hcnJheU9mKHByb3BUeXBlcy5zdHJpbmcpLFxuICAgIC8vIEFuIGFycmF5IHdpdGggNyBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgdGV4dCBmcm9tIFN1biB0byBTYXRcbiAgICBvbkNsaWNrOiBwcm9wVHlwZXMuZnVuYyxcbiAgICAvLyBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgc3F1YXJlIGlzIGNsaWNrZWRcbiAgICBvbk1vdXNlT3ZlcjogcHJvcFR5cGVzLmZ1bmMsXG4gICAgLy8gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBtb3VzZSBwb2ludGVyIGlzIG92ZXIgYSBzcXVhcmVcbiAgICBvbk1vdXNlTGVhdmU6IHByb3BUeXBlcy5mdW5jLFxuICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gbW91c2UgcG9pbnRlciBpcyBsZWZ0IGEgc3F1YXJlXG4gICAgdHJhbnNmb3JtRGF5RWxlbWVudDogcHJvcFR5cGVzLmZ1bmMgLy8gZnVuY3Rpb24gdG8gZnVydGhlciB0cmFuc2Zvcm0gdGhlIHN2ZyBlbGVtZW50IGZvciBhIHNpbmdsZSBkYXlcblxuICB9O1xuICBDYWxlbmRhckhlYXRtYXAuZGVmYXVsdFByb3BzID0ge1xuICAgIG51bURheXM6IG51bGwsXG4gICAgc3RhcnREYXRlOiBkYXRlTkRheXNBZ28oMjAwKSxcbiAgICBlbmREYXRlOiBuZXcgRGF0ZSgpLFxuICAgIGd1dHRlclNpemU6IDEsXG4gICAgaG9yaXpvbnRhbDogdHJ1ZSxcbiAgICBzaG93TW9udGhMYWJlbHM6IHRydWUsXG4gICAgc2hvd1dlZWtkYXlMYWJlbHM6IGZhbHNlLFxuICAgIHNob3dPdXRPZlJhbmdlRGF5czogZmFsc2UsXG4gICAgdG9vbHRpcERhdGFBdHRyczogbnVsbCxcbiAgICB0aXRsZUZvclZhbHVlOiBudWxsLFxuICAgIGNsYXNzRm9yVmFsdWU6IGZ1bmN0aW9uIGNsYXNzRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/ICdjb2xvci1maWxsZWQnIDogJ2NvbG9yLWVtcHR5JztcbiAgICB9LFxuICAgIG1vbnRoTGFiZWxzOiBNT05USF9MQUJFTFMsXG4gICAgd2Vla2RheUxhYmVsczogREFZX0xBQkVMUyxcbiAgICBvbkNsaWNrOiBudWxsLFxuICAgIG9uTW91c2VPdmVyOiBudWxsLFxuICAgIG9uTW91c2VMZWF2ZTogbnVsbCxcbiAgICB0cmFuc2Zvcm1EYXlFbGVtZW50OiBudWxsXG4gIH07XG5cbiAgcmV0dXJuIENhbGVuZGFySGVhdG1hcDtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-calendar-heatmap/dist/react-calendar-heatmap.umd.js\n"));

/***/ })

}]);